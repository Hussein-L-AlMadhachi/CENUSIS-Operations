import {} from 'express';
import * as cookie from 'cookie'; //already used by express so why not
export class RPC {
    functions;
    validator = () => { return { success: true }; };
    constructor() {
        this.functions = new Map();
    }
    async handler(requestData, req, res) {
        const methodName = requestData.method;
        const params = requestData.params;
        if (!methodName) {
            return {
                success: false,
                error: 'bad request: the request need to have "method" and "params"'
            };
        }
        if (typeof methodName !== 'string') {
            return {
                success: false,
                error: "bad request: RPC function doesn't exist"
            };
        }
        if (params && !Array.isArray(params)) {
            return {
                success: false,
                error: "bad request: RPC params should be a list"
            };
        }
        // obtaining RPC from lookup
        const functionHandler = this.functions.get(methodName);
        if (!functionHandler) {
            return {
                success: false,
                error: `RPC function '${methodName}' not found`
            };
        }
        // running auth validator
        const validation = this.validator(req);
        if (validation.success === false) {
            return {
                success: false,
                error: "Authentication failed"
            };
        }
        // passing requests to metadata
        const metadata = validation.metadata || { auth: {} };
        metadata.req = req;
        metadata.res = res;
        // RPC call
        try {
            const result = await functionHandler(metadata, ...(params || []));
            return {
                success: true,
                data: result
            };
        }
        catch (error) {
            console.error(error);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }
    dump() {
        return Array.from(this.functions.keys());
    }
    add(functionHandler, optional_name = null) {
        let func_name;
        if (optional_name) {
            func_name = optional_name;
        }
        else {
            func_name = functionHandler.name;
        }
        if (!func_name) {
            throw new Error('Function must have a name');
        }
        this.functions.set(func_name, functionHandler);
    }
}
export function cookieParser(req, _res, next) {
    const raw_cookies = req.headers.cookie;
    if (!raw_cookies) {
        next();
        return;
    }
    req.cookies = cookie.parse(raw_cookies) || {};
    next();
}
export function createRPC(app, path, validator) {
    const rpc = new RPC();
    rpc.validator = validator;
    if (!app.get("enders-sync-dependencies-loaded")) {
        app.use(cookieParser);
        app.set("enders-sync-dependencies-loaded", true);
    }
    app.get(`${path}/discover`, (req, res) => {
        try {
            const rpcList = rpc.dump();
            res.json(rpcList);
        }
        catch (error) {
            res.status(500).json({ error: 'Internal server error' });
        }
    });
    app.post(`${path}/call`, async (req, res) => {
        try {
            const requestData = req.body;
            if (!requestData || Object.keys(requestData).length === 0) {
                return res.status(400).json({ error: "Invalid JSON" });
            }
            const result = await rpc.handler(requestData, req, res);
            res.json(result);
        }
        catch (error) {
            res.status(500).json({ error: `Internal server error ${error}` });
        }
    });
    return rpc;
}
//# sourceMappingURL=server.js.map